# PoC2: Use After Free

## Description

- **Type**: Use After Free
- **OS**: Microsoft Windows 11 23H2
- **Compiler**: MSVC CL (ARM64)
- **Compiler Version**: 19.38.33133 (ARM64)
- **Compiler Options**: Problematic: all
- **Bug Behavior**: 이 PoC는 MSVC CL 컴파일러에서 잘못된 비교 연산 결과를 보여줍니다. 이러한 오류는 컴파일러의 비정상적인 타입 캐스팅과 연산 처리로 인해 발생합니다.
- **Reported Bug**: [Link to the reported bug](https://developercommunity.visualstudio.com/t/Inconsistent-Comparison-Results-of-Unsig/10521901)

## Bug Demonstration Code

```c
#include <stdio.h>
#define IS_ACTIVE(flag) ((flag - 1) > -1)

struct FlagHolder {
    unsigned isActive : 1;
};

struct FlagHolder flagStatus = {1};

int main () {
    // 비교는 컴파일러 및 아키텍처에 따라 일관되어야 함
    printf("(flagStatus.isActive 1 - 1 > -1) result: %d\n", IS_ACTIVE(flagStatus.isActive));
    flagStatus.isActive = 0;
    printf("(flagStatus.isActive 0 - 1 > -1) result: %d\n", IS_ACTIVE(flagStatus.isActive));
    return 0;
}

```
이 코드는 컴파일러가 unsigned와 signed 타입을 혼동하여 비교 연산을 잘못 처리하는 것을 보여줍니다. 
IS_ACTIVE 매크로는 flag - 1 > -1이라는 비교를 수행합니다. 

MSVC CL 컴파일러에서는 isActive가 1이면 IS_ACTIVE 매크로의 결과가 항상 0(거짓)으로 나옵니다. 

반면, GCC 및 LLVM 컴파일러에서는 isActive가 1일 때 참(1)으로, 0일 때 거짓(0)으로 정상적으로 처리됩니다.

## PoC Code
이 PoC 코드는 MSVC CL 컴파일러의 IS_ACTIVE 매크로 관련 버그를 이용한 Use After Free 취약점을 시연합니다. 

컴파일러 버그로 인해 isActive가 참(1)임에도 불구하고, IS_ACTIVE 매크로가 거짓(0)으로 평가되어 ptr 멤버가 잘못 해제됩니다. 
이후 해제된 ptr에 접근하는 코드에서 Use After Free 취약점이 발생합니다. 

이는 컴파일러 최적화 과정에서의 예기치 않은 동작을 보여주며, 소프트웨어의 보안에 심각한 영향을 미칠 수 있습니다.

```c
#include <stdio.h>
#include <stdlib.h>

#define IS_ACTIVE(flag) ((flag - 1) > -1)

#define NUM_OBJECTS 10

struct Object {
    unsigned isActive : 1; // 사용 여부
    unsigned isFreed : 1;  // free 전에 double free 방지용
    int* ptr;
};

void freeMemberIfNeeded(struct Object** obj) {
		// cl 컴파일러 버그로 인해 isActive가 1임에도 거짓으로 평가됨
		// Active가 0 즉, 사용안할 예정이고 free된 적이 없다면 free
    if (!IS_ACTIVE((*obj)->isActive) && !(*obj)->isFreed) {
        (*obj)->isFreed = 1; // 객체가 해제되었다고 표시
        free((*obj)->ptr); // 메모리 해제
        printf("freed\n");
    }
}

int main() {
    struct Object* objects[NUM_OBJECTS];

    // object 객체 초기화
    for (int i = 0; i < NUM_OBJECTS; i++) {
        objects[i] = malloc(sizeof(struct Object));
        objects[i]->isActive = 1;
        objects[i]->isFreed = 0;
        objects[i]->ptr = malloc(sizeof(int));
        *(objects[i]->ptr) = i;
        printf("%d\n", *(objects[i]->ptr));
    }

    // 객체 해제 시도(active가 아니라면)
    for (int i = 0; i < NUM_OBJECTS; i++) {
        freeMemberIfNeeded(&objects[i]);
    }

    int* something_ptr = malloc(sizeof(int));
    *something_ptr = 100;
    printf("Something ptr value: %d\n", *something_ptr);

    // object에서 해제 안된 것만 재사용 
    for (int i = 0; i < NUM_OBJECTS; i++) {
        // UAF 발생
        if (objects[i]->isActive) {     // UAF 발생
           printf("objects [%d]: %d\n", i, *(objects[i]->ptr));
        }
    }

    return 0;
}
```
## Result
### CL 컴파일러로 빌드한 경우 (UAF 발생)
```
0
1
2
3
4
5
6
7
8
9
freed
freed
freed
freed
freed
freed
freed
freed
freed
freed
Something ptr value: 100
objects [0]: 100
objects [1]: -282391664
objects [2]: 2
objects [3]: 3
objects [4]: 4
objects [5]: -282459824
objects [6]: 6
objects [7]: 7
objects [8]: 8
objects [9]: 9
```
### GCC, LLVM에서 빌드하고 실행한 경우 (UAF 발생 X)
```
0
1
2
3
4
5
6
7
8
9
Something ptr value: 100
objects [0]: 0
objects [1]: 1
objects [2]: 2
objects [3]: 3
objects [4]: 4
objects [5]: 5
objects [6]: 6
objects [7]: 7
objects [8]: 8
objects [9]: 9
```