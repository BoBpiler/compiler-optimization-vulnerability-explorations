#include <stdio.h>
#include <stdlib.h>

#define IS_ACTIVE(flag) ((flag - 1) > -1)

#define NUM_OBJECTS 10

struct Object {
    unsigned isActive : 1; // 사용 여부
    unsigned isFreed : 1;  // free 전에 double free 방지용
    int* ptr;
};

void freeMemberIfNeeded(struct Object** obj) {
		// cl 컴파일러 버그로 인해 isActive가 1임에도 거짓으로 평가됨
		// Active가 0 즉, 사용안할 예정이고 free된 적이 없다면 free
    if (!IS_ACTIVE((*obj)->isActive) && !(*obj)->isFreed) {
        (*obj)->isFreed = 1; // 객체가 해제되었다고 표시
        free((*obj)->ptr); // 메모리 해제
        printf("freed\n");
    }
}

int main() {
    struct Object* objects[NUM_OBJECTS];

    // object 객체 초기화
    for (int i = 0; i < NUM_OBJECTS; i++) {
        objects[i] = malloc(sizeof(struct Object));
        objects[i]->isActive = 1;
        objects[i]->isFreed = 0;
        objects[i]->ptr = malloc(sizeof(int));
        *(objects[i]->ptr) = i;
        printf("%d\n", *(objects[i]->ptr));
    }

    // 객체 해제 시도(active가 아니라면)
    for (int i = 0; i < NUM_OBJECTS; i++) {
        freeMemberIfNeeded(&objects[i]);
    }

    int* something_ptr = malloc(sizeof(int));
    *something_ptr = 100;
    printf("Something ptr value: %d\n", *something_ptr);

    // object에서 해제 안된 것만 재사용 
    for (int i = 0; i < NUM_OBJECTS; i++) {
        // UAF 발생
        if (objects[i]->isActive) {     // UAF 발생
           printf("objects [%d]: %d\n", i, *(objects[i]->ptr));
        }
    }

    return 0;
}