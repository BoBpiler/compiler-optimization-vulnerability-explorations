# PoC3: Heap Overflow

## Description

- **Type**: Heap Overflow
- **OS**: Microsoft Windows 11 23H2
- **Compiler**: MSVC CL (ARM64)
- **Compiler Version**: 19.38.33133 (ARM64)
- **Compiler Options**: Problematic: /O1, /O2, /Ox Normal: /Od, /Ot
- **Bug Behavior**: 이 PoC는 컴파일러 최적화 옵션에 따라 질못된 연산을 수행하는 버그로 인해, 잘못된 사이즈의 메모리를 할당하여 힙 오버플로우가 발생합니다.
- **Reported Bug**: [Link to the reported bug](https://developercommunity.visualstudio.com/t/MSVC-ARM64-Compiler-Incorrectly-Optimize/10510611)

## Bug Demonstration Code
이 코드는 MSVC CL ARM64 컴파일러에서 특정 최적화 옵션(/O1, /O2, /Ox)을 사용할 때 발생하는 예상치 못한 결과를 보여줍니다. 

예제 코드에서 수행되는 연산은 `val << ((0xffff & 0x100) - 0xff)` 형태로, 결과적으로 `val << 1`과 같습니다.

여기서 `val`은 `100`이며, `val << 1` 연산은 `val`에 `2`를 곱하는 것과 같아야 합니다. 

그러나 최적화 옵션에서 이 연산이 잘못 처리되어, 예상과 달리 결과가 `0`으로 계산됩니다. 즉, `val`이 `100`일 때 `val << 1`의 결과는 `200`이 되어야 하지만, 버그로 인해 `0`이 됩니다. 

이러한 버그는 프로그램의 논리적 오류를 유발하고, 보안 취약점으로 이어질 수 있습니다.
```c
#include <stdio.h>

int global_mask = 0xffff; // Global variable, involved in the AND operation

int main() {
    int val = 100;
    int result = 0;
    // AND operation with a second operand of 0x100 or higher causes the issue
    result = (val) << (((global_mask & 0x100)) - 0xff);
    printf("result: %d\n", result);  // Expected to print 200
    return 0;
}
```
## PoC Code
이 PoC 코드는 사용자로부터 입력받은 버퍼 크기를 기반으로 메모리를 할당하고, 사용자의 데이터를 입력받는 간단한 프로그램입니다. 

그러나, 컴파일러 버그로 인해 실제 할당되는 버퍼 크기가 0으로 설정되어 버퍼 오버플로우가 발생합니다. 

이는 실제 프로그램에서 힙 오버플로우 취약점으로 이어질 수 있으며, 이를 통해 악의적인 사용자는 메모리 손상, 정보 유출 또는 임의 코드 실행과 같은 보안 위협을 유발할 수 있습니다.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_BUFFER_SIZE 1000  // 최대 버퍼 크기 제한

// 실질적인 연산은 size << 0으로 size 반환버그로 인해 실제로는 0 반환 but 버그로 인해서 0 반환
int global_mask = 0xffff;
#define BUFFER_SIZE_CALCULATION(size) ((size) << (((global_mask & 0x100)) - 0x100)) 


int validateBufferSize(int size) {
    // 버퍼 크기가 음수가 아니고 최대치를 넘지 않는지 검증
    if (size > 0 && size <= MAX_BUFFER_SIZE) {
        // 버그를 통해 실제 버퍼 크기를 0으로 설정
        return BUFFER_SIZE_CALCULATION(size); // 버그를 통해 실제 버퍼 크기를 0으로 설정
    } else {
        // 잘못된 크기 입력에 대한 처리
        printf("Invalid buffer size. Please enter a size between 1 and %d.\n", MAX_BUFFER_SIZE);
        return -1;
    }
}

int main() {
    int userBufferSize;
    printf("Enter the buffer size you want to allocate: ");
    scanf("%d", &userBufferSize); // 사용자로부터 버퍼 크기 입력 받음

    int bufferSize = validateBufferSize(userBufferSize); // 실제 버퍼 크기 계산 (버그로 인해 0)
    if (bufferSize < 0) {
        return 1; // 잘못된 입력 처리
    }
    
    printf("buffer size: %d\n", bufferSize);  // 버그가 발생했음을 명시적으로 확인하기 위함

    // 사용자가 입력한 크기와 무관하게 실제 할당은 버그에 의해 결정됨
    char *buffer = (char *)malloc(bufferSize);
    if (!buffer) {
        perror("Failed to allocate buffer");
        return 1;
    }

    // 데이터 입력 받기
    printf("Enter your data: ");
    getchar(); // 이전 입력의 newline 제거
    fgets(buffer, userBufferSize, stdin); // 사용자가 입력한 크기로 데이터 입력 받음

    printf("You entered: %s\n", buffer);

    free(buffer);
    return 0;
}
```
## Result
### /Od /Ot: 정상 동작
```
Enter the buffer size you want to allocate: 100
buffer size: 100
Enter your data: BoBpiler fighting ~~~ we can do this ~~~~~~~~~
You entered: BoBpiler fighting ~~~ we can do this ~~~~~~~~~
```
### /O1 /O2 /Ox: 힙 오버플로우로 인한 크래시
```
Enter the buffer size you want to allocate: 100
buffer size: 0 // 버그가 발생했음을 명시적으로 확인하기 위함
Enter your data: BoBpiler fighting ~~~ we can do this ~~~~~~~~~ BoBpiler fighting ~~~ we can do this ~~~~~~~~~ BoBpiler fighting ~~~ we can do this ~~~~~~~~~
You entered: BoBpiler fighting ~~~ we can do this ~~~~~~~~~ BoBpiler fighting ~~~ we can do this ~~~~~~~~~ BoBpi
크래시...
```
